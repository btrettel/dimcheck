# To-do

Priorities:

- `string_` to `character_`
- `*_equality_test` to `eq` with generics, similar for others.
- `%logical_test(.not.` to `%false(`
- Remove all `fmutate` annotations.
- Convert passed.py to passed.f90.
- Convert all .jsonl files to .nml.
- Merge tests from `test_*.py` into the associated Fortran test files.
- Make as much as possible `pure`.
- `nmllog.f90`: Switch to Fortran namelist-based logging so that everything is in Fortran.
    - Check your notes for the following:
        - /home/ben/notes/programming/file-formats-locations.txt section titled "logging"
        - /home/ben/notes/programming/correctness/defensive-programming.txt section titled "error/exception handling and error messages"
- f90lint: Start with procedure length enforcement.
- `io.f90`:
    - convenience subroutines
        - `box_print` (other similar things for the most important messages that I don't want to miss)
            - <https://fortran-lang.discourse.group/t/fortran-code-snippets/2150/24>
        - `table_print` for iterative progress in particular.

New modules and tools:

- dimmod.f90, dimgen.f90: Generates a module named `dimcheck` which provides compile-time checking of dimensions. (started, paused for now)
- fad.f90: Forward-mode automatic differentiation. (complete but not yet added)
- ga.f90: Module for derivative-free optimization of `real`s with a genetic algorithm.
    - Make ga.f90 use rngmod.f90.
    - herrera_tackling_1998
    - Have multiple outputs.
        - `chromo%f`
        - `chromo%f_set`
        - `chromo%out(:)` (for non-objective function outputs that may be of interest)
- debugtype.f90: Module which implements a derived type to replace `real` with the following debugging capabilities:
    - Monte Carlo sensitivity analysis on floating point operations to help identify expressions contributing to floating point inaccuracy. This allows to find operations with inaccuracy worse than a threshold, rather than finding *all* inexact floating-point operations as tools like gfortran's `ffpe-trap=inexact` do. The latter approach leads to too many reported problems. Prioritizing floating-point errors by their magnitude makes sense.
        - parker_monte_1997-1
    - FLOP counting.
- f90lint: Simple linter for Fortran to enforce anything that can't be enforced with a regex linter.
    - Enforce some Power of 10 rules, particularly procedure lengths.
    - Start tracking comment density and adding more code comments. Density > 25%?
    - Require that all functions are pure.
    - Require construct names for nested `do` loops and `if` statements.
- fmutate.f90:
    - Note: This will be brittle in the sense that it will only work for my own particular coding style.
    - Distinguish between compilation errors and test failures in the mutation score.
    - Mutation operators:
        - TODO: Check Mothra and other papers on DTIC for more.
        - `comment_line`: Comment out non-empty lines.
        - `switch_arithmetic_operator`: Switch arithmetic operators (`+`, `-`, `*`, `/`).
        - `switch_comparison_operator`: Switch comparison operators (`>`, `<`, `==`, `>=`, `<=`, `/=`).
        - `off_by_one_assignment`: Add or subtract one in an assignment (or start of a loop).
        - `off_by_one_do_loop_end`: Add or subtract one at the end of a loop
        - `off_by_one_indices_or_arguments`: Add or subtract one in indices or procedure arguments.
        - TODO: mutation operators like the off-by-one operators that change the sign.
        - `switch_variables`: Switch variables.
        - `return`: Prematurely `return` in a procedure.
        - `cycle`: Prematurely `cycle` in a loop.
        - `exit`: Prematurely `exit` in a loop.
        - `zero`: Set a variable to zero in an assignment (or at the start of a loop).
        - `function_result`: Mutate `function` result values.
        - `subroutine_out`: Mutate subroutine `intent(out)` and `intent(in out)` values.
        - `array_size`: Increase or decrease array sizes by one.
        - `delete_term`: Delete random equation terms. (Thought after skimming [this paper](https://doi.org/10.1115/1.4049322): Code coverage misses equation terms. A mutation tester which deletes random equation terms could be useful.)
        - Swap intrinsics like sin and cos which are likely to be accidentally switched.
        - Mutate `intent(in)` to `intent(out)`.
        - Mutate `intent(out)` to `intent(in)`.
        - Change order of exponentiation: `x**y` to `y**x`.
- make_checker.py: Runs both GNU Make and BSD Make on all targets and identifies which fail.
- rng.f90: Includes a deterministic random number generator for testing purposes.
    - Base the interface on NumPy:
        - <https://numpy.org/doc/stable/reference/random/generator.html>
    - Start with non-`pure` RNGs and later switch to `pure` like NumPy's:
        - <https://numpy.org/neps/nep-0019-rng-policy.html>
- semgrep static analysis
- compiler_tests.f90: Tests for intrinsics used in these libraries.
    - How can I identify all the intrinsics used here?
- Program to ensure that all error codes in errors and assertions are unique.
- <https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method>
- <https://en.wikipedia.org/wiki/Variance-based_sensitivity_analysis>
- Break `prec.f90` into `types_dp.f90` and `types_sp.f90`. Both of these modules will be named `types` and are interchangeable. These modules only define `RP`. Constants like `PI` should then go in a separate `constants.f90` file which depends on the `types` module choice.
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/types.f90>
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/constants.f90>
- unittest.f90:
    - Print tolerance in output.
    - Use better `is_close` not using `epsilon`. `spacing` might be better if the round-off error is within a certain amount of the local spacing?
        - <https://fortran-lang.discourse.group/t/suggestion-findloc-tolerance/5131/5>
            - FortranFan seems skeptical.
        - <https://stdlib.fortran-lang.org/page/specs/stdlib_math.html#is_close-function>
    - Make `real_equality_test` and `real_inequality_test` use `is_close`.
- input validation
    - Write module to ease input validation. For example, a subroutine to write a message about a variable being out of bounds.
    - `call validate_bounds(x, "x", rc, lower=0, lower_inclusive=.true.)`
        - message: "x must be greater than or equal to 0."
    - `call validate_bounds(x, "x", rc, lower=0)`
        - message: "x must be greater than 0."
        - I don't think that this is not inclusive is obvious enough.
- data validation
    - Base on <https://pandera.readthedocs.io/en/stable/index.html>?
- latex.f90:
    - Calculated numbers in papers: Write procedure to output LaTeX code to a file (appending by default) with a particular number format. Could pass in a Fortran format string.
- read and save CSV and Sqlite files:
    - regex validation field for CSV
- fuzz.f90: property/fuzz tester
    - Property and fuzz tests on procedures and input files
    - Make depend on ga.f90
    - namelist generator for fuzzing
- convergence.f90: convergence testing framework
    - grid convergence
    - temporal convergence
    - MC convergence
- Add validation subroutines (AIC, cross-validation, basic idea of checking whether model is within experimental uncertainty as often as it should be, etc.), calibration subroutines (genetic algorithm for modeling fitting, MCMC to handle uncertainties, etc.)
