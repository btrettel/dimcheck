# To-do

Priorities:

- Make nmllog.f90 optionally not print the time and/or level to stdout.
- `make install` to install pdim_gen.
- pdim_mod.f90, pdim_gen.f90: Generates a module named `pdim_types` which provides compile-time checking of physical dimensions. (started)
    - refactor
        - Break pdim_mod into multiple modules to help organization.
        - `n_interfaces` is passed into some subroutines but not others. Make the interfaces consistent.
        - `MAX_LABEL_LEN` vs. `LABEL_LEN` is confusing.
        - Make better notation.
            - Distinguish between `i_pdim`/`n_pdims` and `i_exponent`/`n_exponents` (`n_exponents` may not be the best terminology)
    - Break up `write_module` to make testing parts easier.
        - Subroutine to generate `pdims`.
    - `pdim_types.f90`
        - Unary negation.
        - Elementary functions like `sin`, `cos`, `log`, etc.
        - `unit` function to return array of exponents of corresponding unit (Implement with an `interface` with many `module procedures` listed, one for each unit? That would increase the number of interfaces for ifx, unfortunately.)
        - `dimension` function to return string with dimension (implement with an `interface` with many `module procedures` listed, one for each unit)
        - function to format type to string with units or dimensions
            - Can specify SI units for printing?
        - derived type I/O for printing?
    - Unit tests for all procedures.
    - Characterization test comparing against known valid `units.f90`.
    - Test exponentiation functions.
    - Compare compile and run times with and without `pdim_types`. Look at compile time for `pdim_types.mod` and also something calling the module separately.
        - `make benchmark`
    - `pdim_gen.f90`: Read namelist file specified as command line argument, generate `pdim_types.f90`.
        - Print number of operators created.
    - `pdim_label`: Eliminate "magic number" of 5 (used in 10000 as well) and make it part of `config`
    - Better type names:
        - Type names which lead to good error messages are best. Example error messages:
            - gfortran: `Error: Cannot convert TYPE(t_3f800000_00000000_bf800000) to TYPE(t_3f800000_00000000_00000000) at (1)`. This indicates that there's a physical dimension checking error, but isn't clear about what the expected and actual dimensions are.
            - ifx: `error #6197: An assignment of different structure types is invalid.` (So ifx doesn't say what the types are.)
    - Namelist function to define setup.
        - `pdim` namelist to specify physical dimensions to make shortcuts for, like `length` instead of `pdim_*_*_*`.
            - Also use this to generate the required dimensions. Only generate dimensions created by combinations of the specified dimensions. This would reduce comilation time. This would also eliminate the need for the nested loops that restrict the number of physical dimensions to a predetermined number, and eliminate the need for `exponent_deltas`.
    - How to handle physical dimensions with AD?
        - `diff(f, x)`: Different return types depending on `x` and `y`.
        - But how can I link `x` to the index of the `dv` member variable? I could try something like `diff(f, x, 1)` where `1` is the index.
        - Alternatively, for `diff(f, x)`, since `x` doesn't actually correspond to the *numerical value* of `x`, `x` could be a variable with the same type and a value `x%v` which corresponds to the index to differentiate with respect to.
        - I could make `x` a different type than whatever its physical dimensions would imply. This different type would be a differential version which could contain the index instead of the value.
    - Test with AD.
    - Test with arrays instead of scalars.
    - Recursion to handle arbitrary numbers of exponents.
    - `real(...)` to convert `dimless` to `real(kind=WP)` for when an intrinsic or something else that expects a `real(kind=WP)` isn't available. Also: `int`.
    - Table with times for various compilers on the same computer, as a function of number of pdims generated:
        - Running pdim_gen
        - Compiling pdim_types.f90
        - Compiling test.f90 with pdim_types
        - Compiling test_real.f90 without pdim_types (otherwise identical)
        - Running test.f90 with pdim_types
        - Running test_real.f90 without pdim_types (otherwise identical, to show effect on run-time performance)

Later:

- add names to deeply nested `if`s and `do`s in unittest
- Search for `TODO` and finish those tasks.
- fmutate.f90:
    - Start with deleting lines and one other mutation operator. The reason to have two is to have the infrastructure for multiple mutation operators from the start.
    - Get papers for FORTRAN 77 mutation tester to see what that did.
        - acree_mutation_1979
        - budd_mutation_1979
        - king_fortran_1991
            - <https://web.archive.org/web/20221016055309/http://cs.gmu.edu/~offutt/rsrch/mut.html#MOTHRA>
    - Avoid dependency on external regex library. Build in the minimum regex that you need.
    - Make mutation rules in a human-readable file. This will allow you to easily add new rules. A namelist file would work.
    - Check /home/ben/notes/programming/correctness/code-testing.txt for more ideas.
    - Note: This will be brittle in the sense that it will only work for my own particular coding style.
    - Distinguish between compilation errors and test failures in the mutation score.
    - Make highly parallelizable.
        - Apply the mutation operators in batches in parallel. This will require a pure random number generator.
        - Run the compiler in the next stage in parallel. This will allow me to note if the compilation fails as well.
        - In the next stage, queue the codes that compiled and run them in parallel.
    - List tests that always pass. Check these tests to make sure that they actually discriminate between working and non-working code.
        - List percent of times a test fails with a mutation. Sort the list to see which tests are most and least sensitive/discriminating.
        - For tests that always pass, reduce tolerances so that the tests are more sensitive.
        - For faster testing, consider eliminating tests which always pass, particularly if they take a long time.
    - Mutation operators:
        - `comment_line`: Comment out non-empty lines.
        - `switch_arithmetic_operator`: Switch arithmetic operators (`+`, `-`, `*`, `/`).
        - `switch_comparison_operator`: Switch comparison operators (`>`, `<`, `==`, `>=`, `<=`, `/=`).
        - `off_by_one_assignment`: Add or subtract one in an assignment (or start of a loop).
        - `off_by_one_do_loop_end`: Add or subtract one at the end of a loop
        - `off_by_one_indices_or_arguments`: Add or subtract one in indices or procedure arguments.
        - TODO: mutation operators like the off-by-one operators that change the sign.
        - `switch_variables`: Switch variables.
        - `return`: Prematurely `return` in a procedure.
        - `cycle`: Prematurely `cycle` in a loop.
        - `exit`: Prematurely `exit` in a loop.
        - `zero`: Set a variable to zero in an assignment (or at the start of a loop).
        - `function_result`: Mutate `function` result values.
        - `subroutine_out`: Mutate subroutine `intent(out)` and `intent(in out)` values.
        - `array_size`: Increase or decrease array sizes by one.
        - `delete_term`: Delete random equation terms. (Thought after skimming [this paper](https://doi.org/10.1115/1.4049322): Code coverage misses equation terms. A mutation tester which deletes random equation terms could be useful.)
        - Swap intrinsics like sin and cos which are likely to be accidentally switched.
        - Mutate `intent(in)` to `intent(out)`.
        - Mutate `intent(out)` to `intent(in)`.
        - Change order of exponentiation: `x**y` to `y**x`.
        - changing order of magnitude of numbers
        - moving parentheses (common mistake)
    - When complete, add here: <https://fortranwiki.org/fortran/show/Mutation+testing+frameworks>
- `purerng`:
    - Make xoshiro256** only work with `REAL64` and `INT64` with radix 2 as it seems designed around those based on the bit manipulation.
    - Change `I10` to `INT64` to work with xoshiro256**.
    - Test that `INT64` has enough precision for the `lecuyer` RNG.
    - `set_determ`: Convenience function to convert `real` array to `RNG_DETERM` seed
    - For arrays: One `rng_type` per `harvest`. `random_seed` uses spacing in lecuyer_efficient_1988 to set for arrays.
        - lecuyer_implementing_1991
    - Create `stats` module with `mean` and `std` to do some basic tests on the `RNG_LECUYER` random number generator.
        - <https://stdlib.fortran-lang.org/page/specs/stdlib_stats.html>
        - <https://en.wikipedia.org/wiki/Variance#Unbiased_sample_variance>
        - <https://en.wikipedia.org/wiki/Continuous_uniform_distribution>
    - Move `rand_int`, `rand_uniform`, and `rand_cauchy` from ga.f90 to `purerng`. Change their names to be more similar to SciPy or NumPy.
    - better `random_seed()`
    - Switch `random_seed` to use a return code rather than `error stop` to make it more easily tested?
- compiler_tests.f90: Tests for intrinsics used in these libraries.
    - How can I identify all the intrinsics used here?
    - accuracy of important intrinsics
- ga.f90: Module for derivative-free optimization of `real`s with a genetic algorithm.
    - Make ga.f90 use rngmod.f90.
    - herrera_tackling_1998
    - Have multiple outputs.
        - `chromo%f`
        - `chromo%f_set`
        - `chromo%out(:)` (for non-objective function outputs that may be of interest)
- debugtype.f90: Module which implements a derived type to replace `real` with the following debugging capabilities:
    - Monte Carlo sensitivity analysis on floating point operations to help identify expressions contributing to floating point inaccuracy. This allows to find operations with inaccuracy worse than a threshold, rather than finding *all* inexact floating-point operations as tools like gfortran's `ffpe-trap=inexact` do. The latter approach leads to too many reported problems. Prioritizing floating-point errors by their magnitude makes sense.
        - parker_monte_1997-1
    - FLOP counting.
    - Something like Monte Carlo arithmetic can be used to identify sections of code that contribute the most to uncertainty, like Monte Carlo arithmetic finds sections of code that are most sensitive to round-off error.
    - metcalf_modern_2018 p. 309: type-bound operators so that you don't have to `use` the operators
    - Use `pure` logging for this?
- nmlfuzz.f90: namelist fuzz tester
    - Make depend on ga.f90
    - Use metaprogramming to make work since Fortran can't really do that well at present?
        - Have a computer-generated module that converts from genetic algorithm chromosome to namelist.
    - Make similar to <https://en.wikipedia.org/wiki/American_Fuzzy_Lop_(software)>.
    - Use fuzzing primarily to find assertion violations with integration tests.
    - I guess the objective function includes the code coverage and whether or not an assertion violation occurred.
- f90lint: Simple linter for Fortran to enforce anything that can't be enforced with a regex linter.
    - Enforce some Power of 10 rules, particularly procedure lengths.
    - Start tracking comment density and adding more code comments. Density > 25%?
    - Require that all functions are pure.
    - Require construct names for nested `do` loops and `if` statements.
    - Check that assertions have unique messages. List relevant variable values in error message.
- semgrep static analysis
- Program to ensure that all error codes in errors and assertions are unique.
- <https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method>
- <https://en.wikipedia.org/wiki/Variance-based_sensitivity_analysis>
- input validation
    - Write module to ease input validation. For example, a subroutine to write a message about a variable being out of bounds.
    - `call validate_bounds(x, "x", rc, lower=0, lower_inclusive=.true.)`
        - message: "x must be greater than or equal to 0."
    - `call validate_bounds(x, "x", rc, lower=0)`
        - message: "x must be greater than 0."
        - I don't think that this is not inclusive is obvious enough.
- data validation
    - Base on <https://pandera.readthedocs.io/en/stable/index.html>?
- latex.f90:
    - Calculated numbers in papers: Write procedure to output LaTeX code to a file (appending by default) with a particular number format. Could pass in a Fortran format string.
- read and save CSV and Sqlite files:
    - regex validation field for CSV
- convergence.f90: convergence testing framework
    - grid convergence
    - temporal convergence
    - MC convergence
- Add validation subroutines (AIC, cross-validation, basic idea of checking whether model is within experimental uncertainty as often as it should be, etc.), calibration subroutines (genetic algorithm for modeling fitting, MCMC to handle uncertainties, etc.)
- Poisson solvers, using same or similar interface as FISHPACK
    - <https://people.sc.fsu.edu/~jburkardt/f77_src/fishpack/fishpack.html>
        - Old: <https://people.math.sc.edu/Burkardt/f77_src/fishpack/fishpack.html>
    - <https://github.com/firemodels/fds/blob/master/Source/pois.f90>
    - <https://github.com/jlokimlin/fishpack>
    - <https://www.netlib.org/fishpack/>
    - <https://ascl.net/1609.005>
    - <https://arc.ucar.edu/knowledge_base/71991310>
        - <https://github.com/NCAR/NCAR-Classic-Libraries-for-Geophysics>
- Add a generic Makefile template for Fortran projects to FLT.
- `io.f90`:
    - convenience subroutines
        - `print_box` (other similar things for the most important messages that I don't want to miss)
            - <https://fortran-lang.discourse.group/t/fortran-code-snippets/2150/24>
        - `print_table*` for iterative progress in particular.
            - `print_table_heading`
            - `print_table_row` (different versions for integer first columns and character first columns?)
            - Also useful for input to compare defaults and current values. See oran_numerical_1987 p. 75.
            - Column heading could go off-screen for long tables, so reprint the heading periodically?
        - `print_dict`
            - Inspired by <https://youtu.be/PxmvTsrCTZg?t=103>:
                - `iteration=2200 residual=0.0937`
            - This is good for long lists because the column header in the table can go off-screen.
        - Look into how other CFD softwares output iterative progress for ideas. Which metrics do they output?
- Makefile
    - Change Makefile to make object files of the `test_*.f90` files and list the dependencies only once?
    - Fortran Makefile dependency generator
    - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/18>:
        - > I will note that from a quick scan of your script and makefile, it doesn’t actually appear to guarantee correct order of compilation (i.e. your .o files don’t depend on .mod files).
    - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/23>
        - > For Fortran, an object file depends on the source file it is compiled from AND all the .mod files for any modules USEd in the source file. A .mod file depends on the source file in which that module is defined. An executable depends on all the object files for all the code it uses, and code they use, etc, even if that code wasn’t in a module, and so doesn’t get included via a USE statement.
    - <https://aoterodelaroza.github.io/devnotes/modern-fortran-makefiles/>
    - <https://fortran-lang.org/en/learn/building_programs/project_make/>
- Add tests to compare speed of parallel vs. serial
- unittest.f90
    - maybe: Instead of `integer_eq`, `real_eq`, use generic `eq`?
    - Ensure that all test messages are unique.
    - Keep track of test results so that you know whether a test has ever failed, and thus whether it is discriminating. (bowes_how_2017 p. 3L)
- Break `prec.f90` into `types_dp.f90` and `types_sp.f90`. Both of these modules will be named `types` and are interchangeable. These modules only define `RP`. Constants like `PI` should then go in a separate `constants.f90` file which depends on the `types` module choice.
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/types.f90>
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/constants.f90>
- A module containing errno codes, other internal return codes, and exit codes. Could make a derived type with the number and a message.
- Detect if certain compilers are present and don't run those in `make all` if they are not present. This will allow your Makefile to work on all your different computers.
- Make an assertion which takes an array to help avoid the problem of only the first failing assertion
    - `check` helps with this too, but an `assert_all` would be convenient if I simply want to check a bunch of things at once.
    - <https://blog.ploeh.dk/2022/11/07/applicative-assertions/>
    - Can make `assert_all` use `do_concurrent` to have a faster assertion.
- timer.f90
    - Data type contains both CPU time and wall clock time for comparison?
    - Tests
        - serial case where CPU and wall time should be close.
        - parallel case where CPU time should be a multiple of wall time
        - separate non-standard test code using `sleep(1)`
            - <https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gfortran/SLEEP.html>
            - <https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2024-0/sleep.html>
- `purerng`
    - Add more rigorous tests for random number generators. (Low priority as I just implemented a common random number generator, which should be good enough to get started.)
- regex.f90 (Could be useful for fmutate.f90.)
    - <https://fortran-lang.discourse.group/t/the-maturity-of-the-fortran-open-source-ecosystem/7563/2>
    - <https://github.com/perazz/fortran-regex>
    - Fork, add asserts and tests? Or just use as-is to get started faster?
- autodiff.f90
    - Modify your AD to use SIMD vectorization. Use `do concurrent` with OpenMP or OpenACC directives? See personal notes on automatic differentiation for other speed ideas too.
    - Can declare certain derivatives as "active" or "inactive to easily enable or disable (respectively) differentiation with respect to particular variables at compile or run time for speed. Not yet sure how to pick `dv` indices in this case. With allocatable `dv`, this can be done at run time.
- To-do routine in code to cause compilation to fail.
- `nmllog`
    - When nvfortran supports writing namelists to internal variables, support adding a custom namelist to the output. Then you can have custom variables in `nmllog` output.
- Add linters.
    - Flinter
        - Add directory for flinter in tests to make sure that Flinter actually flags bad code. Have one test for good code too which should not be flagged.
    - Camfort
    - <http://simconglobal.com/fpt_summary.html>
    - <https://fortran.uk/fortran-analysis-and-refactoring-with-plusfort/plusfort-evaluation-version/>
    - <https://www.forcheck.nl/index.html>
- pdim_mod.f90:
    - For reading data from CSV files, a compile-time check can't be done. But you can make a derived type which contains the exponents, and corresponding subroutines to check that the output type matches the input type. There will have to be a lot of auto-generated subroutines, but it'll work.
