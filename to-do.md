# To-do

Priorities:

- Search for `TODO` and finish those tasks.
- Eliminate Python from this repository.
    - Eliminate passed.f90 as it probably does not serve any purpose given that all modern compilers should have non-zero exit codes if I specific the exit code specifically. I now recall that I had this before for ELF90, which doesn't allow exit codes. There's no other reason to have it. crayftn has a zero exit code for `error stop "message"`, but I won't use that for the tests. I should have another check for that case when doing a full run integration test.
    - Remove Python from .gitignore.
- Make as much as possible `pure`.
- `random`
    - rename `rngmod` to `random`
    - Make `pure` random number generator. Obtain random number generator from elsewhere as you're not qualified to program one.
    - Use standard tests for random number generators to make sure this one is good.
    - Move `rand_int` and `rand_cauchy` to `random`.
- unittest.f90:
    - Use better `is_close` not using `epsilon`. `spacing` might be better if the round-off error is within a certain amount of the local spacing?
        - <https://fortran-lang.discourse.group/t/suggestion-findloc-tolerance/5131/5>
            - FortranFan seems skeptical.
        - <https://stdlib.fortran-lang.org/page/specs/stdlib_math.html#is_close-function>
    - Make `real_eq` and `real_ne` use `is_close`.
    - `%logical_true(.not.` to `%logical_false(`
- timer.f90
    - Make `unittest` use this for the timing.
    - `timer_type`: `started` (`logical` that says whether the timer is currently timing), `wall_sum` (time before current timer start), `wall_start`, `wall_stop`, `cpu_sum`, `cpu_start`, `cpu_stop`
        - Maybe later: `wall_precision`, `cpu_precision`
    - Base interface on <https://math.nist.gov/StopWatch/QUICKSTART>, for example: `timer%start()`, `timer%stop`, `timer%reset()`, etc.
    - In test output, write how long test took to run so that you know how long each test takes?
    - `timer%start()` before what you want to time
    - `timer%end()` after
    - Make the derived type have 0 time when initialized. Then you can start the timer again with start.
    - `timer%seconds`
    - <https://youtu.be/qUeud6DvOWI?t=322>
        - `time.perf_counter()`
        - <https://docs.python.org/3/library/time.html#time.perf_counter>
    - Data type contains both CPU time and wall clock time for comparison?
    - <https://docs.python.org/3/library/timeit.html>
        - `result = timeit(subroutine_with_no_arguments, number=10000)`
        - <https://news.ycombinator.com/item?id=22085172>
            - Return minimum time to account for OS jitter?
            - Return multiple times I guess to get a better idea of the overall distribution.
    - Tests
        - serial case where CPU and wall time should be close.
        - parallel case where CPU time should be a multiple of wall time
        - separate non-standard test code using `sleep(1)`
            - <https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gfortran/SLEEP.html>
            - <https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2024-0/sleep.html>
- A module containing errno codes, other internal return codes, and exit codes. Could make a derived type with the number and a message.
- fmutate.f90:
    - TODO: Look at mutation testing literature for particular types of errors to introduce.
    - TODO: Get papers for FORTRAN 77 mutation tester to see what that did.
    - Note: This will be brittle in the sense that it will only work for my own particular coding style.
    - Distinguish between compilation errors and test failures in the mutation score.
    - <https://fortran-lang.discourse.group/t/the-maturity-of-the-fortran-open-source-ecosystem/7563/2>
    - Make highly parallelizable. Run as many mutants as possible in parallel for speed. The compiler can't run on GPUs, but the code can. So run the compiler separately in a first pass. This will allow me to note if the compilation fails as well. Then queue the codes that compiled and run them on GPUs. I'm not sure the extent by which the GPU runs can be parallelized, however.
    - List tests that never fail. Those tests may always pass, so they should be checked to make sure that they actually discriminate between working and non-working code.
        - List percent of times a test fails with a mutation. Sort the list to see which tests are most and least sensitive/discriminating.
        - For tests that always pass, reduce tolerances so that the tests are more sensitive.
        - For faster testing, consider eliminating tests which always pass, particularly if they take a long time.
    - Mutation operators:
        - TODO: Check Mothra and other papers on DTIC for more.
        - `comment_line`: Comment out non-empty lines.
        - `switch_arithmetic_operator`: Switch arithmetic operators (`+`, `-`, `*`, `/`).
        - `switch_comparison_operator`: Switch comparison operators (`>`, `<`, `==`, `>=`, `<=`, `/=`).
        - `off_by_one_assignment`: Add or subtract one in an assignment (or start of a loop).
        - `off_by_one_do_loop_end`: Add or subtract one at the end of a loop
        - `off_by_one_indices_or_arguments`: Add or subtract one in indices or procedure arguments.
        - TODO: mutation operators like the off-by-one operators that change the sign.
        - `switch_variables`: Switch variables.
        - `return`: Prematurely `return` in a procedure.
        - `cycle`: Prematurely `cycle` in a loop.
        - `exit`: Prematurely `exit` in a loop.
        - `zero`: Set a variable to zero in an assignment (or at the start of a loop).
        - `function_result`: Mutate `function` result values.
        - `subroutine_out`: Mutate subroutine `intent(out)` and `intent(in out)` values.
        - `array_size`: Increase or decrease array sizes by one.
        - `delete_term`: Delete random equation terms. (Thought after skimming [this paper](https://doi.org/10.1115/1.4049322): Code coverage misses equation terms. A mutation tester which deletes random equation terms could be useful.)
        - Swap intrinsics like sin and cos which are likely to be accidentally switched.
        - Mutate `intent(in)` to `intent(out)`.
        - Mutate `intent(out)` to `intent(in)`.
        - Change order of exponentiation: `x**y` to `y**x`.
        - changing order of magnitude of numbers
        - moving parentheses (common mistake)

Later:

- dimmod.f90, dimgen.f90: Generates a module named `dimcheck` which provides compile-time checking of dimensions. (started, paused for now)
- fad.f90: Forward-mode automatic differentiation. (complete but not yet added)
    - Modify your AD to be vectorized. See personal notes on automatic differentiation for other speed ideas too.
- ga.f90: Module for derivative-free optimization of `real`s with a genetic algorithm.
    - Make ga.f90 use rngmod.f90.
    - herrera_tackling_1998
    - Have multiple outputs.
        - `chromo%f`
        - `chromo%f_set`
        - `chromo%out(:)` (for non-objective function outputs that may be of interest)
- debugtype.f90: Module which implements a derived type to replace `real` with the following debugging capabilities:
    - Monte Carlo sensitivity analysis on floating point operations to help identify expressions contributing to floating point inaccuracy. This allows to find operations with inaccuracy worse than a threshold, rather than finding *all* inexact floating-point operations as tools like gfortran's `ffpe-trap=inexact` do. The latter approach leads to too many reported problems. Prioritizing floating-point errors by their magnitude makes sense.
        - parker_monte_1997-1
    - FLOP counting.
    - Something like Monte Carlo arithmetic can be used to identify sections of code that contribute the most to uncertainty, like Monte Carlo arithmetic finds sections of code that are most sensitive to round-off error.
- f90lint: Simple linter for Fortran to enforce anything that can't be enforced with a regex linter.
    - Enforce some Power of 10 rules, particularly procedure lengths.
    - Start tracking comment density and adding more code comments. Density > 25%?
    - Require that all functions are pure.
    - Require construct names for nested `do` loops and `if` statements.
    - Check that assertions have unique messages. List relevant variable values in error message.
- make_checker.py: Runs both GNU Make and BSD Make on all targets and identifies which fail.
- rng.f90: Includes a deterministic random number generator for testing purposes.
    - Base the interface on NumPy:
        - <https://numpy.org/doc/stable/reference/random/generator.html>
    - Start with non-`pure` RNGs and later switch to `pure` like NumPy's:
        - <https://numpy.org/neps/nep-0019-rng-policy.html>
- semgrep static analysis
- compiler_tests.f90: Tests for intrinsics used in these libraries.
    - How can I identify all the intrinsics used here?
- Program to ensure that all error codes in errors and assertions are unique.
- <https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method>
- <https://en.wikipedia.org/wiki/Variance-based_sensitivity_analysis>
- input validation
    - Write module to ease input validation. For example, a subroutine to write a message about a variable being out of bounds.
    - `call validate_bounds(x, "x", rc, lower=0, lower_inclusive=.true.)`
        - message: "x must be greater than or equal to 0."
    - `call validate_bounds(x, "x", rc, lower=0)`
        - message: "x must be greater than 0."
        - I don't think that this is not inclusive is obvious enough.
- data validation
    - Base on <https://pandera.readthedocs.io/en/stable/index.html>?
- latex.f90:
    - Calculated numbers in papers: Write procedure to output LaTeX code to a file (appending by default) with a particular number format. Could pass in a Fortran format string.
- read and save CSV and Sqlite files:
    - regex validation field for CSV
- fuzz.f90: property/fuzz tester
    - Property and fuzz tests on procedures and input files (namelist files)
    - Make depend on ga.f90
    - Make clone of Hypothesis/etc.
    - Fuzzers can *optimize*, but property testing can only look at binary outcomes?
- convergence.f90: convergence testing framework
    - grid convergence
    - temporal convergence
    - MC convergence
- Add validation subroutines (AIC, cross-validation, basic idea of checking whether model is within experimental uncertainty as often as it should be, etc.), calibration subroutines (genetic algorithm for modeling fitting, MCMC to handle uncertainties, etc.)
- `test_compiler.f90`: Tests for different compilers.
    - accuracy of important intrinsics
    - `precision(1)` shows that the default integer has sufficient precision
- Poisson solvers, using same or similar interface as FISHPACK
    - <https://people.sc.fsu.edu/~jburkardt/f77_src/fishpack/fishpack.html>
        - Old: <https://people.math.sc.edu/Burkardt/f77_src/fishpack/fishpack.html>
    - <https://github.com/firemodels/fds/blob/master/Source/pois.f90>
    - <https://github.com/jlokimlin/fishpack>
    - <https://www.netlib.org/fishpack/>
    - <https://ascl.net/1609.005>
    - <https://arc.ucar.edu/knowledge_base/71991310>
        - <https://github.com/NCAR/NCAR-Classic-Libraries-for-Geophysics>
- Add a generic Makefile template for Fortran projects to FLT.
- `nmllog.f90`: Switch to Fortran namelist-based logging so that everything is in Fortran.
    - Option to not write at all, even to file?
    - Check your notes for the following:
        - /home/ben/notes/programming/file-formats-locations.txt section titled "logging"
        - /home/ben/notes/programming/correctness/defensive-programming.txt section titled "error/exception handling and error messages"
- f90lint: Start with procedure length enforcement.
- `io.f90`:
    - convenience subroutines
        - `print_box` (other similar things for the most important messages that I don't want to miss)
            - <https://fortran-lang.discourse.group/t/fortran-code-snippets/2150/24>
        - `print_table*` for iterative progress in particular.
            - `print_table_heading`
            - `print_table_row` (different versions for integer first columns and character first columns?)
            - Also useful for input to compare defaults and current values. See oran_numerical_1987 p. 75.
            - Column heading could go off-screen for long tables, so reprint the heading periodically?
        - `print_dict`
            - Inspired by <https://youtu.be/PxmvTsrCTZg?t=103>:
                - `iteration=2200 residual=0.0937`
            - This is good for long lists because the column header in the table can go off-screen.
        - Look into how other CFD softwares output iterative progress for ideas. Which metrics do they output?
- Makefile
    - Change Makefile to make object files of the `test_*.f90` files and list the dependencies only once?
    - Fortran Makefile dependency generator
    - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/18>:
        - > I will note that from a quick scan of your script and makefile, it doesn’t actually appear to guarantee correct order of compilation (i.e. your .o files don’t depend on .mod files).
    - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/23>
        - > For Fortran, an object file depends on the source file it is compiled from AND all the .mod files for any modules USEd in the source file. A .mod file depends on the source file in which that module is defined. An executable depends on all the object files for all the code it uses, and code they use, etc, even if that code wasn’t in a module, and so doesn’t get included via a USE statement.
    - <https://aoterodelaroza.github.io/devnotes/modern-fortran-makefiles/>
    - <https://fortran-lang.org/en/learn/building_programs/project_make/>
- Add tests to compare speed of parallel vs. serial
- unittest.f90 maybe: Instead of `integer_eq`, `real_eq`, use generic `eq`?

- Break `prec.f90` into `types_dp.f90` and `types_sp.f90`. Both of these modules will be named `types` and are interchangeable. These modules only define `RP`. Constants like `PI` should then go in a separate `constants.f90` file which depends on the `types` module choice.
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/types.f90>
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/constants.f90>
