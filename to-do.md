# To-do

Priorities:

- convergence.f90: convergence testing framework
    - grid/temporal convergence (set up the same: take a callback where one parameter is the delta to be varied)
        - produce both error and order plots
        - `convergence_rate(func, deltas, norm, outfile, expected_order, tol, actual_order, rc)`
            - `norm` can be `NORM_POINTWISE` or `NORM_INFINITY`
            - `actual_order` is `intent(out)`
        - Convergence error plot assumes positive discretization error (or implicit norm of some sort), order plot does not
        - `rc` can be used to catch issues like the criteria of nishikawa_pitfalls_2023 being unmet, etc.
    - MC convergence
        - Could simply design `convergence_rate` to handle this as well. Flag does sampling properly, etc.
    - Richardson extrapolation procedure
- Because `make depends` requires some genunits output to be generated, it's not possible to start `make depends` from nothing. Have option to start `make depends` from nothing.
- genunits
    - Change `config%intrinsics` to `unitless_1arg_intrinsics` array in nml file that is looped over to minimize number of interfaces, reduce amount of hard coded things, and reduce number of places to change when adding unitless 1 argument intrinsics
    - 2 argument `min` and `max`
    - Generic `linspace` and `linf_norm`
    - Test unitless intrinsics.
    - Add comparison operators, including `real` for `unitless`, with tests.
    - Look into inheritance for genunits to avoid the `%v%v` problem?
    - Better constructor for AD and genunits. Make default constructor set a constant, and have a separate subroutine to set the variable number of the derivatives? Example proposed syntax for combination of AD and genunits:
        - ```type(si_length) :: x

        x = si_length(1.0_WP) ! make a constant
        call x%set_dv(1, N_DV) ! set this as variable number 1```
    - Add `%v%v` to linter (disabled for now) to help identify what to fix in the future...
- `make lint` runs Python linters too.
- Track and/or limit number of `if` statements to reduce number of test cases needed, accelerate code due to less branch prediction, and make the code more differentiable.
- Make script to install FLT build system in a directory
- Documentation for genunits
    - `use_line` creates a new line at semicolons, so that depends.py can see the dependency.
- genunits_io.f90: Change type-bound procedures for `config` to be normal procedures.
- fmad.f90:
    - Addition and subtraction for `real`s (with tests).
    - Assert that `dv` of the output is allocated (via `assert`) and has correct size (via `assert_dimension`).
    - comparison operators for reals, with tests
- Better constructors for AD. I should be able to get a constant by using `ad` directly.
- Make `test_concurrent` more reliable. I think this problem might only appear for Intel. And is it only for release mode as an assertion should catch this? Why don't the assertions fail in that case?
    - ```./test_purerng
    real returned = -3999.7052
           > real = .0000000
    fail: test_concurrent, greater than zero```
- transient.py: Repeatedly run tests looking for transient failures, saving results when a transient failure is encountered.
- depends.py: Generates a list of executables from `app` in before.mk, add them to `CLEAN`.
- Add Valgrind back to check-fc. Suppress namelist derived-type input problem in Valgrind.
    - <https://valgrind.org/docs/manual/manual-core.html#manual-core.suppress>
    - <https://stackoverflow.com/a/23897854/1124489>
    - Old: Selectively use Valgrind for all code that you're confident will not have false positives. Add a list of tests that fail Valgrind to config.ini (`no_valgrind`) and make depends.py generate the associated Makefile components.
- returncodes.f90: A module containing `errno` codes, other internal return codes.
    - Make a table of `iostat` values in different Fortran compilers so that you know which values to pick to not conflict with any compiler.
        - <https://fortranwiki.org/fortran/show/iso_fortran_env>
            - `iostat_end`, `iostat_eor`
        - <https://www.scivision.dev/oneapi-fortran-iostat-codes/>
        - <https://www.ibm.com/docs/en/xl-fortran-linux/16.1.1?topic=inputoutput-conditions-iostat-values>
        - <https://groups.google.com/g/comp.lang.fortran/c/l8UJoI-x9PM>
- Makefile documentation: Explain `DFLAGS`, `RFLAGS`, `AFLAGS` (architecture flags), `NFLAGS` (native architecture flags).
- `make install` to install everything in `app`.
    - `DESTDIR` and `PREFIX` variables
    - <https://nullprogram.com/blog/2017/08/20/>
    - <https://www.gnu.org/software/make/manual/html_node/Directory-Variables.html>
    - <https://www.gnu.org/software/make/manual/html_node/DESTDIR.html>
- `make dist`
    - create tgz and/or zip file of `DESTDIR`
    - lists hashes
- Add `PFLAGS` to enable or disable parallelization for debug and release. OpenMP and other libraries can't be statically linked, so they might lead to portability issues if they aren't used but are dynamically linked and aren't available.
    - `THREADING=serial` vs. `THREADING=parallel`
- `ARCH=gpu` for ifx and nvfortran. `GFLAGS` for GPU flags?
- nmllog.f90
    - `check_bounds(x, rc, lower, upper)`
        - Both `lower` and `upper` are optional, but at least one of the two must be `present`.
        - `integer` version can optionally use `<=`, etc.
- grad.f90: gradient descent
    - Turn off derivative calculation in backtracking line search by making the `dv` member variables have zero length.
    - <https://www.tensorflow.org/guide/core/optimizers_core>
        - Help plan interface to gradient descent
    - Make gradient descent able to select which variables to optimize, as I usually will not be interested in optimizing all variables. Some variables are for UQ only.
    - Works with units.f90? Might be more trouble than it's worth, but give it a shot.
- genunits: Generates a module named `units` which provides compile-time checking of physical dimensions. (started)
    - Derived type input
        - Make derived type input end at a ` `, `,`, or `/`. See NAG email.
        - Allow for prefixes like `m`, `c`, `k` on each unit? A base unit can be defined by a base symbol and a base prefix. So the base unit `kg` is constructed from the base symbol `g` and the base prefix `k`.
            - <https://ucum.org/ucum#baseunits>
            - <https://en.wikipedia.org/wiki/Unit_prefix>
        - Use `vlist` for something else. `size(vlist)` seems to cause problems with nvfortran. See 2024-07-06 log.
    - How to handle physical dimensions with AD?
        - `diff(f, x)`: Different return types depending on `x` and `y`.
        - Link `x` to the index of the `dv` member variable by making the only non-zero `dv` member variable the one to differentiate with respect to.
    - Namelist group `template` which will read in a template and create versions of the procedure for all units and the proper interface block. Until Fortran has good generics, this is the only way to get a generic procedure.
        - `&template file="file.f90" /`
        - Examples:
            - `is_close`
            - `swap_alloc` for all units. This takes two arguments and has a non-trivial procedure body, so it can't be handled like intrinsics.
    - Add feature to generate a module to allow for basic math on "vectors" where each row has a different unit. Implement "vectors" as derived types. Vector is probably not the right word.
        - <https://github.com/arjenmarkus/handling-units/blob/main/src/handling_units_dimensions.tex>
            - > If the feature does not support arrays whose elements have different dimensions/units of measure, then certain use patterns are not possible. That may or may not be a breaking requirement for the feature.
- Build testing
    - FreeBSD in a virtual machine
        - <https://cyber.dabamos.de/programming/modernfortran/fortran-compilers.html>
    - Windows in a virtual machine
        - Windows and the virtual machine itself
            - <https://www.microsoft.com/software-download/windows11>
            - <https://sysguides.com/install-a-windows-11-virtual-machine-on-kvm>
            - <https://www.youtube.com/watch?v=7tqKBy9r9b4>
            - <https://sysguides.com/share-files-between-the-kvm-host-and-windows-guest-using-virtiofs>
        - Build systems
            - GNU Make
                - <https://stackoverflow.com/a/73862277/1124489>
                    - Windows 10+: `winget install ezwinports.make`
            - NMAKE from Visual Studio Build Tools
            - Jom
                - <https://wiki.qt.io/Jom>
        - Compilers
            - gfortran
                - <https://fortran-lang.org/learn/os_setup/install_gfortran/#windows>
                - <https://gcc.gnu.org/wiki/GFortranBinaries#Windows>
            - FTN95
            - ifx
                - <https://www.intel.com/content/www/us/en/docs/fortran-compiler/get-started-guide/2024-2/get-started-on-windows.html>
                    - > To build applications using command-line tools only, you must have a supported version of Build Tools for Visual Studio installed.
                - <https://visualstudio.microsoft.com/downloads/>
        - Other:
            - MikTeX
            - Python
                - <https://docs.python.org/3/using/windows.html>
                - <https://learn.microsoft.com/en-us/windows/python/beginners>
    - Mac OS
- Automatic stencil code generation. Less likely to have errors, can automatically optimize to satisfy certain constraints.
- Count test_units.f90 and test_units_ad.f90 towards test_genunits_io.f90?
- When work has ifx 2024.2, change `assert` to eliminate `full_message` by putting the message directly on the `error stop` line. Also see [compiler-bugs report0002](https://github.com/btrettel/compiler-bugs/tree/main/report0002).
- f90lint.py: Track and/or limit number of `if` statements to reduce number of test cases needed, accelerate code due to less branch prediction, and make the code more differentiable.
- fmad.f90 and units.f90
    - `is_close`

Later:

- f90lint:
    - No programs in source, no modules in app or test.
    - List longest subroutines
- port.f90
    - Get all tests to pass on Windows.
    - Wrapper for `execute_command_line` that handles `./` on \*nix vs. nothing on Windows and file extension (nothing vs. `.exe`).
    - Differences between Windows and \*nix
        - `rm_cmd`: `del /q` vs. `rm`
        - `rmdir_cmd`: `rmdir /s /q` vs. `rmdir`
        - `cd_cmd`: `cd` vs. `cd`
        - `mv_cmd`: `move` vs. `mv`
        - `cp_cmd`: `copy` vs. `cp`
        - `mkdir_cmd`: `mkdir` vs. `mkdir`
        - `cmd_separator`: `&` vs. `;`
        - `dir_separator`: `\` vs. `/`
        - `binext`: `.exe` vs. ``
        - `run`: nothing vs. `./`
        - `cmp`: `fc` vs. `cmp`
    - Note: Would be faster to detect platform at compile-time, but more convoluted. Given that I probably won't be calling these commands in a way that will impact performance much, I'm not worried about it.
- Common issue in my Fortran code: not using `lbound` and `ubound`
    - Do arrays passed into procedures maintain these index bounds?
    - For all array procedures, have tests with non-default array lower bounds to check if array bounds are preserved.
        - Make `unittest` subroutine similar to `assert_dimension` that takes two `class(*)` arrays of various sizes and fails if the bounds/dimensions don't match.
- Option to disable automatic differentiation in Makefile for speed.
- genunits
    - Derived-type I/O
        - read/write number with uncertainty
    - `same_unit` function which have same units for input and output: `abs`, `maxval`, `minval`, etc.
        - `max` and `min` would be hard as they take an arbitrary number of arguments.
    - `unitless` functions which have unitless input and output (like `sin`, `cos`, `log`, `exp`, `gamma`, etc.). Include possible `use` line in namelist group.
    - `unit` function to return array of exponents of corresponding unit (Implement with an `interface` with many `module procedures` listed, one for each unit? That would increase the number of interfaces for ifx, unfortunately.)
    - `dimension` function to return string with dimension (implement with an `interface` with many `module procedures` listed, one for each unit)
    - Add assertions to the generated module (if appropriate), and have the option to enable or disable assertions.
    - Remove dependency on nmllog so that this can be separated out more easily.
        - This will also help to compile genunits with lfortran, though it's not sufficient as `is_close` won't compile with lfortran due to `spacing`.
    - Break `write_module` into multiple modules to help organization and make testing parts easier.
    - `n_interfaces` is passed into some subroutines but not others. Make the interfaces consistent.
    - Unit tests for all procedures.
    - Characterization test comparing against known valid `units.f90`.
    - Test exponentiation functions.
    - Compare compile and run times with and without `units`. Look at compile time for `units.mod` and also something calling the module separately.
        - `make benchmark`
    - Better type names:
        - Type names which lead to good error messages are best. Example error messages:
            - gfortran: `Error: Cannot convert TYPE(unit_p10000_p00000_m10000) to TYPE(unit_p10000_p00000_p00000) at (1)`. This indicates that there's a physical dimension checking error, but isn't clear about what the expected and actual dimensions are.
            - ifx: `error #6197: An assignment of different structure types is invalid.` (So ifx doesn't say what the types are.)
    - Add `test_unit` to genunits_io.f90 to write to test file.
    - As comments, print number of types and interfaces at the end of the generated file, along with genunits git revision information, and the namelist file used to generate the file.
    - Test with arrays instead of scalars.
    - `real(...)` to convert `unitless` to `real(kind=WP)` for when an intrinsic or something else that expects a `real(kind=WP)` isn't available. Also: `int`.
    - Table with times for various compilers on the same computer, as a function of number of units generated:
        - Running genunits
        - Compiling units.f90
        - Compiling test_units.f90 with units
        - Compiling test_real.f90 without units (otherwise identical)
        - Running test_units.f90 with units
        - Running test_real.f90 without units (otherwise identical, to show effect on run-time performance)
    - Compare error messages in different compilers for units.f90
        - If necessary, request that lfortran type error message be similar to gfortran to be as useful as possible for units.f90.
        - Have a documentation section listing what various error messages shown by various compilers mean. Some of these error messages are not particularly clear and that harms debugging. Also note which compilers have more useful error messages for genunits.
    - units test with operations on 3 or more different units to make sure the output is correct
    - Check for spaces at the end of lines.
    - Lint the generated file units.f90.
    - absolute vs. offset vs. relative units
- add names to deeply nested `if`s and `do`s in unittest
- Search for `TODO` and finish those tasks.
- fmutate.f90:
    - Start with deleting lines and one other mutation operator. The reason to have two is to have the infrastructure for multiple mutation operators from the start.
    - Get papers for FORTRAN 77 mutation tester to see what that did.
        - acree_mutation_1979
        - budd_mutation_1979
        - king_fortran_1991
            - <https://web.archive.org/web/20221016055309/http://cs.gmu.edu/~offutt/rsrch/mut.html#MOTHRA>
    - Avoid dependency on external regex library. Build in the minimum regex that you need.
    - Make mutation rules in a human-readable file. This will allow you to easily add new rules. A namelist file would work.
    - Check /home/ben/notes/programming/correctness/code-testing.txt for more ideas.
    - Note: This will be brittle in the sense that it will only work for my own particular coding style.
    - Distinguish between compilation errors and test failures in the mutation score.
    - Mutation tester should not touch assertions.
        - But it should note which assertions never fail as below.
    - Make highly parallelizable.
        - Apply the mutation operators in batches in parallel. This will require a pure random number generator.
        - Run the compiler in the next stage in parallel. This will allow me to note if the compilation fails as well.
        - In the next stage, queue the codes that compiled and run them in parallel.
    - List tests that always pass. Check these tests to make sure that they actually discriminate between working and non-working code.
        - List percent of times a test fails with a mutation. Sort the list to see which tests are most and least sensitive/discriminating.
        - For tests that always pass, reduce tolerances so that the tests are more sensitive.
        - For faster testing, consider eliminating tests which always pass, particularly if they take a long time.
    - Mutation operators:
        - `comment_line`: Comment out non-empty lines.
        - `switch_arithmetic_operator`: Switch arithmetic operators (`+`, `-`, `*`, `/`).
        - `switch_comparison_operator`: Switch comparison operators (`>`, `<`, `==`, `>=`, `<=`, `/=`).
        - `off_by_one_assignment`: Add or subtract one in an assignment (or start of a loop).
        - `off_by_one_do_loop_end`: Add or subtract one at the end of a loop
        - `off_by_one_indices_or_arguments`: Add or subtract one in indices or procedure arguments.
        - TODO: mutation operators like the off-by-one operators that change the sign.
        - `switch_variables`: Switch variables.
        - `return`: Prematurely `return` in a procedure.
        - `cycle`: Prematurely `cycle` in a loop.
        - `exit`: Prematurely `exit` in a loop.
        - `zero`: Set a variable to zero in an assignment (or at the start of a loop).
        - `function_result`: Mutate `function` result values.
        - `subroutine_out`: Mutate subroutine `intent(out)` and `intent(in out)` values.
        - `array_size`: Increase or decrease array sizes by one.
        - `delete_term`: Delete random equation terms. (Thought after skimming [this paper](https://doi.org/10.1115/1.4049322): Code coverage misses equation terms. A mutation tester which deletes random equation terms could be useful.)
        - Swap intrinsics like sin and cos which are likely to be accidentally switched.
        - Mutate `intent(in)` to `intent(out)`.
        - Mutate `intent(out)` to `intent(in)`.
        - Change order of exponentiation: `x**y` to `y**x`.
        - changing order of magnitude of numbers
        - moving parentheses (common mistake)
    - When complete, add here: <https://fortranwiki.org/fortran/show/Mutation+testing+frameworks>
- `purerng`:
    - RNG splitting
    - `set_determ`: Convenience function to convert `real` array to `RNG_DETERM` seed
    - For arrays: One `rng_type` per `harvest`. `random_seed` uses spacing in lecuyer_efficient_1988 to set for arrays.
        - lecuyer_implementing_1991
    - Create `stats` module with `mean` and `std` to do some basic tests on the `RNG_LECUYER` random number generator.
        - <https://stdlib.fortran-lang.org/page/specs/stdlib_stats.html>
        - <https://en.wikipedia.org/wiki/Variance#Unbiased_sample_variance>
        - <https://en.wikipedia.org/wiki/Continuous_uniform_distribution>
    - Move `rand_int`, `rand_uniform`, and `rand_cauchy` from ga.f90 to `purerng`. Change their names to be more similar to SciPy or NumPy.
    - better `random_seed()`
    - Switch `random_seed` to use a return code rather than `error stop` to make it more easily tested?
- compiler_tests.f90: Tests for intrinsics used in these libraries.
    - How can I identify all the intrinsics used here?
    - accuracy of important intrinsics
- debugtype.f90: Module which implements a derived type to replace `real` with the following debugging capabilities:
    - Monte Carlo sensitivity analysis on floating point operations to help identify expressions contributing to floating point inaccuracy. This allows to find operations with inaccuracy worse than a threshold, rather than finding *all* inexact floating-point operations as tools like gfortran's `ffpe-trap=inexact` do. The latter approach leads to too many reported problems. Prioritizing floating-point errors by their magnitude makes sense.
        - parker_monte_1997-1
    - FLOP counting.
    - Something like Monte Carlo arithmetic can be used to identify sections of code that contribute the most to uncertainty, like Monte Carlo arithmetic finds sections of code that are most sensitive to round-off error.
    - metcalf_modern_2018 p. 309: type-bound operators so that you don't have to `use` the operators
    - Use `pure` logging for this?
    - Upper and lower bounds for each variable, report violations.
- Have Python script to insert probes into (instrument) Fortran code, particularly for Monte Carlo arithmetic.
    - <https://fortran-lang.discourse.group/t/free-plusfort-licence-for-fortran-discourse-users/2609/5?u=btrettel>
        - > SPAG is able to insert calls to probes at various points in your code (see below).
    - <https://docs.cypress.io/guides/tooling/code-coverage>
    - Don't insert probes into `pure` and `elemental` procedures?
    - Use `pure` logging for this so that it'll work in `pure` procedures?
    - <https://flibs.sourceforge.net/checking.html>
        - <https://sourceforge.net/p/flibs/svncode/HEAD/tree/trunk/src/checking/>
- nmlfuzz.f90: namelist fuzz tester
    - Intentionally pick inputs which pass input validation but cause the program to fail.
    - Make depend on ga.f90
        - Alternatively: Combine fuzzing and automatic differentiation when possible to find bad program states.
    - Use metaprogramming to make work since Fortran can't really do that well at present?
        - Have a computer-generated module that converts from genetic algorithm chromosome to namelist.
    - Make similar to <https://en.wikipedia.org/wiki/American_Fuzzy_Lop_(software)>.
    - Use fuzzing primarily to find assertion violations with integration tests.
    - I guess the objective function includes the code coverage and whether or not an assertion violation occurred.
    - For speed, incentivize causing assertion failures as quickly as possible. The objective function is a function of both whether the code ran successfully or not and how quickly it failed if it did fail.
- f90lint: Simple linter for Fortran to enforce anything that can't be enforced with a regex linter.
    - Enforce some Power of 10 rules. Procedure lengths?
    - Measure and enforce code comment density? Assertions count towards this.
        - <https://dirkriehle.com/2009/02/04/the-sweet-spot-of-code-commenting-in-open-source/comment-page-1/>
    - Require construct names for nested `do` loops and `if` statements.
    - Check that assertions have unique messages. List relevant variable values in error message.
- semgrep static analysis
- <https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method>
- Sensitivity analysis for model parameters.
    - <https://en.wikipedia.org/wiki/Variance-based_sensitivity_analysis>
    - Use AD for sensitivity analysis for important inputs? Make it possible to turn off AD for these inputs during "production" runs for speed.
- input validation
    - Write module to ease input validation. For example, a subroutine to write a message about a variable being out of bounds.
    - `call validate_bounds(x, "x", rc, lower=0, lower_inclusive=.true.)`
        - message: "x must be greater than or equal to 0."
    - `call validate_bounds(x, "x", rc, lower=0)`
        - message: "x must be greater than 0."
        - I don't think that this is not inclusive is obvious enough.
- data validation
    - Base on <https://pandera.readthedocs.io/en/stable/index.html>?
- latex.f90:
    - Calculated numbers in papers: Write procedure to output LaTeX code to a file (appending by default) with a particular number format. Could pass in a Fortran format string.
    - Include in io.f90?
- read and save CSV and Sqlite files:
    - regex validation field for CSV
- Add model validation subroutines (AIC, cross-validation, basic idea of checking whether model is within experimental uncertainty as often as it should be, etc.), calibration subroutines (genetic algorithm for modeling fitting, MCMC to handle uncertainties, etc.)
- Poisson solvers, using same or similar interface as FISHPACK
    - <https://people.sc.fsu.edu/~jburkardt/f77_src/fishpack/fishpack.html>
        - Old: <https://people.math.sc.edu/Burkardt/f77_src/fishpack/fishpack.html>
    - <https://github.com/firemodels/fds/blob/master/Source/pois.f90>
    - <https://github.com/jlokimlin/fishpack>
    - <https://www.netlib.org/fishpack/>
    - <https://ascl.net/1609.005>
    - <https://arc.ucar.edu/knowledge_base/71991310>
        - <https://github.com/NCAR/NCAR-Classic-Libraries-for-Geophysics>
- `io.f90`:
    - convenience subroutines
        - `print_box` (other similar things for the most important messages that I don't want to miss)
            - <https://fortran-lang.discourse.group/t/fortran-code-snippets/2150/24>
        - `print_table*` for iterative progress in particular.
            - `print_table_heading`
            - `print_table_row` (different versions for integer first columns and character first columns?)
            - Also useful for input to compare defaults and current values. See oran_numerical_1987 p. 75.
            - Column heading could go off-screen for long tables, so reprint the heading periodically?
        - `print_dict`
            - Inspired by <https://youtu.be/PxmvTsrCTZg?t=103>:
                - `iteration=2200 residual=0.0937`
            - This is good for long lists because the column header in the table can go off-screen.
        - Look into how other CFD softwares output iterative progress for ideas. Which metrics do they output?
- Add tests to compare speed of parallel vs. serial
- unittest.f90
    - maybe: Instead of `integer_eq`, `real_eq`, use generic `eq`?
    - Ensure that all test messages are unique.
    - Keep track of test results so that you know whether a test has ever failed, and thus whether it is discriminating. (bowes_how_2017 p. 3L)
- Break `prec.f90` into `types_dp.f90` and `types_sp.f90`. Both of these modules will be named `types` and are interchangeable. These modules only define `WP`. Constants like `PI` should then go in a separate `constants.f90` file which depends on the `types` module choice.
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/types.f90>
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/constants.f90>
- Detect if certain compilers are present and don't run those in `make all` if they are not present. This will allow your Makefile to work on all your different computers.
- Make an assertion which takes an array to help avoid the problem of only the first failing assertion
    - `check` helps with this too, but an `assert_all` would be convenient if I simply want to check a bunch of things at once.
    - <https://blog.ploeh.dk/2022/11/07/applicative-assertions/>
    - Can make `assert_all` use `do_concurrent` to have a faster assertion.
- timer.f90
    - Data type contains both CPU time and wall clock time for comparison?
    - Tests
        - serial case where CPU and wall time should be close.
        - parallel case where CPU time should be a multiple of wall time
        - separate non-standard test code using `sleep(1)`
            - <https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gfortran/SLEEP.html>
            - <https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2024-0/sleep.html>
- `purerng`
    - Add more rigorous tests for random number generators. (Low priority as I just implemented a common random number generator, which should be good enough to get started.)
- regex.f90 (Could be useful for fmutate.f90.)
    - <https://fortran-lang.discourse.group/t/the-maturity-of-the-fortran-open-source-ecosystem/7563/2>
    - <https://github.com/perazz/fortran-regex>
    - Fork, add asserts and tests? Or just use as-is to get started faster?
- fmad.f90
    - Modify your AD to use SIMD vectorization. Use `do concurrent` with OpenMP or OpenACC directives? See personal notes on automatic differentiation for other speed ideas too.
    - Can declare certain derivatives as "active" or "inactive to easily enable or disable (respectively) differentiation with respect to particular variables at compile or run time for speed. Not yet sure how to pick `dv` indices in this case. With allocatable `dv`, this can be done at run time.
- To-do routine in code to cause compilation to fail.
- `nmllog`
    - When nvfortran supports writing namelists to internal variables, support adding a custom namelist to the output. Then you can have custom variables in `nmllog` output.
- Add linters.
    - Add directory for flinter in tests to make sure that Flinter actually flags bad code. Have one test for good code too which should not be flagged.
    - Camfort
    - <http://simconglobal.com/fpt_summary.html>
    - <https://fortran.uk/fortran-analysis-and-refactoring-with-plusfort/plusfort-evaluation-version/>
    - <https://www.forcheck.nl/index.html>
- genunits:
    - For reading data from CSV files, a compile-time check can't be done. But you can make a derived type which contains the exponents, and corresponding subroutines to check that the output type matches the input type. There will have to be a lot of auto-generated subroutines, but it'll work.
    - FPM installation
    - New GitHub repository specifically for this.
    - Advertising:
        - Post on Fortran Discourse.
        - Create Fortran Wiki page on "Physical units" and list it there.
- Bayesian inference Fortran module, to solve basic problems like the probabity of actually having breast cancer in Yudkowsky's "intyutive explanation" or whodunits. Use log probability or whatever is appropriate internally.
- Along side fmutate, make a simple test case reduction program for Fortran (freduce?). Just delete lines to reduce test cases.
    - <https://gcc.gnu.org/pipermail/fortran/2009-October/030302.html>
- dataplot-like approach to ease adding tests (but use namelists instead of a single CSV file)
- Use exiftool in combination with gnuplot to add metadata to plots to (for example) ease identification of which data was used to produce the plot. Add comments to DXF files to do the same.
- Verify checksums of all generated images that have them (PNG, for example).
- Build system improvements:
    - Fortran module dependencies being wrong
        - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/18>
            - > I will note that from a quick scan of your script and makefile, it doesn’t actually appear to guarantee correct order of compilation (i.e. your .o files don’t depend on .mod files).
        - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/23>
            - > For Fortran, an object file depends on the source file it is compiled from AND all the .mod files for any modules USEd in the source file. A .mod file depends on the source file in which that module is defined. An executable depends on all the object files for all the code it uses, and code they use, etc, even if that code wasn’t in a module, and so doesn’t get included via a USE statement.
    - Making compatible with FPM.
- Tests
    - Test `exit_code_eq` better. Check if the file is kept or not.
    - Make sure that debug builds enable assertions by looking at the test log output.
- Build system improvements:
    - Making work with NMAKE, GNU Make, and BSD Make.
        - Figure out how to pass the `-f` argument to the `MAKE` macro so that recursive make works (for example, `bmake -f BSDmakefile all` and `pdpmake -f PDPmakefile all`).
        - Figure out how to specify `BUILD` and `FC` in pdpmake.
        - Figure out how to add back `test ! -e fort.*` and `test ! -e FORT.*` to tests as I don't know what the Windows equivalent is.
            - Do these checks in Fortran?
- interval arithmetic
    - Combination with automatic differentiation: <http://www.mscs.mu.edu/%7Egeorgec/IFAQ/rocco1.html>
- `constrained` data type
    - <http://www.acorvid.com/2017/12/13/what-i-miss-when-writing-fortran/>
        - > Constrained reals; for example, absolute mass, pressure, or temperature variables which throw an exception if they become negative. This is a first-class feature of types in Ada (constrained subtype)
    - Can be done with a derived type with custom operators.
- Build system improvements:
    - Replace PDPmakefile with POSIXmakefile that is strictly POSIX (has no `include` or any other non-POSIX things) and should work on IBM AIX make too. This file can be constructed from the other files via `make POSIXmakefile`. Don't set `FC` and whatnot, instead set those via the command line or defaults?
    - Intel and Cray compilers: make variable to switch between address and thread sanitizers, compile with both when doing `make all` (`SFLAGS`?)
    - `PFLAGS` make macro to switch between GPU and CPU for ifx, nvfortran, etc.
- f90lint:
    - Add tests for remaining modules which aren't passing.
    - Check for modules which don't have tests.
    - Measure `TODO` density and have bound on it to keep them current.
    - Identify untested procedures by looking at `use` lines in tests. This won't work for type-bound procedures, though.
    - Require that all functions be `pure`.
    - Output checking:
        - Presence of files that should not be there: `fort.*`, `FORT.*`
        - Fortran format overflow: `*` in ifort/gfortran/crayftn/nvfortran
        - `forrtl: error`
        - `NaN`
        - `Infinity`
- purerng.f90 low priority:
    - Make xoshiro256** only work with `REAL64` and `INT64` with radix 2 as it seems designed around those based on the bit manipulation.
    - Change `I10` to `INT64` to work with xoshiro256**.
    - Test that `INT64` has enough precision for the `lecuyer` RNG.
- nmlcli.f90
    - Could modify `get_namelist` approach to make CLI use more typical `--` flags. `--flag` could also be converted to `flag=.true.` for `logical`s.
    - Wouldn't work on nvfortran as nvfortran can't `read` namelists from internal variables?
    - `--version`: integrates with revision.f90
    - How can I get descriptions of each option in `--help`? Manually? Parsing comments in the namelist file that is included?
    - <https://fortran-lang.discourse.group/t/are-namelists-portable/1212/10>
    - <https://github.com/urbanjost/M_CLI?tab=readme-ov-file>
    - <https://fortranwiki.org/fortran/show/get_namelist>
- Multidimensional Newton solver
    - <https://web.mit.edu/18.06/www/Spring17/Multidimensional-Newton.pdf>
        - <https://gcc.gnu.org/onlinedocs/gfortran/NORM2.html>
    - <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html>
    - <https://people.sc.fsu.edu/~jburkardt/f_src/newton_rc/newton_rc.html>
    - Newton solver using AD taking a callback.
    - Would be advantageous to only have needed derivatives for the iteration and add additional derivatives for the final run.
    - Can return solutions for arbitrary arrays.
    - <https://twitter.com/chenna1985/status/1802660023010513012>
- How to do pure Monte Carlo uncertainty propagation? Include the RNG type in the MC derived type? So I need a thread-safe seed generator first.
- ga.f90: Module for derivative-free optimization of `real`s with a genetic algorithm.
    - Make ga.f90 use rngmod.f90.
    - herrera_tackling_1998
    - Have multiple outputs.
        - `chromo%f`
        - `chromo%f_set`
        - `chromo%out(:)` (for non-objective function outputs that may be of interest)
- `CMP` based tests
- Smart pointers
    - Develop smart pointers before reverse mode AD.
- Maybe: Remove units*.f90 and rev.f90 from `skip_indexing` for f90lint to lint those files. Make `make f90lint` depend on the generated files so that they are present for linting.
