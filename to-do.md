# To-do

Priorities:

- f90lint:
    - No programs in source, no modules in app or test.
    - List longest subroutines
- port.f90
    - Get all tests to pass on Windows.
    - Wrapper for `execute_command_line` that handles `./` on \*nix vs. nothing on Windows and file extension (nothing vs. `.exe`).
    - Differences between Windows and \*nix
        - `rm_cmd`: `del /q` vs. `rm`
        - `rmdir_cmd`: `rmdir /s /q` vs. `rmdir`
        - `cd_cmd`: `cd` vs. `cd`
        - `mv_cmd`: `move` vs. `mv`
        - `cp_cmd`: `copy` vs. `cp`
        - `mkdir_cmd`: `mkdir` vs. `mkdir`
        - `cmd_separator`: `&` vs. `;`
        - `dir_separator`: `\` vs. `/`
        - `binext`: `.exe` vs. ``
        - `run`: nothing vs. `./`
        - `cmp`: `fc` vs. `cmp`
    - Note: Would be faster to detect platform at compile-time, but more convoluted. Given that I probably won't be calling these commands in a way that will impact performance much, I'm not worried about it.
- Common issue in my Fortran code: not using `lbound` and `ubound`
    - Do arrays passed into procedures maintain these index bounds?
    - For all array procedures, have tests with non-default array lower bounds to check if array bounds are preserved.
        - Make `unittest` subroutine similar to `assert_dimension` that takes two `class(*)` arrays of various sizes and fails if the bounds/dimensions don't match.
- grad.f90: gradient descent
    - Cubic line search, test if local minimum
    - <https://www.tensorflow.org/guide/core/optimizers_core>
        - Help plan interface to gradient descent
    - Make gradient descent able to select which variables to optimize, as I usually will not be interested in optimizing all variables. Some variables are for UQ only. Make gradient descent include robust optimization by default, taking into account the uncertainty.
- genunits: Generates a module named `units` which provides compile-time checking of physical dimensions. (started)
    - Derived-type I/O
        - metcalf_modern_2018 pp. 261--264
        - `write(formatted)`
        - `write(formatted)` and `read(formatted)` for namelists (`iotype == "namelist"`)? Then I could have units or uncertainty in a namelist!
    - Remove dependency on nmllog so that this can be separated out more easily.
        - This will also help to compile genunits with lfortran, though it's not sufficient as `is_close` won't compile with lfortran due to `spacing`.
    - Break `write_module` into multiple modules to help organization and make testing parts easier.
    - `n_interfaces` is passed into some subroutines but not others. Make the interfaces consistent.
    - Add `test_unit` to genunits_io.f90 to write to test file.
    - As comments, print number of types and interfaces at the end of the generated file, along with genunits git revision information, and the namelist file used to generate the file.
    - `units.f90`
        - Comparison operators.
        - Elementary functions which have same units for input and output.
        - `custom` functions which have unitless input and output (like `sin`, `cos`, `log`, etc.). Include possible `use` line in namelist group.
        - `unit` function to return array of exponents of corresponding unit (Implement with an `interface` with many `module procedures` listed, one for each unit? That would increase the number of interfaces for ifx, unfortunately.)
        - `dimension` function to return string with dimension (implement with an `interface` with many `module procedures` listed, one for each unit)
        - function to format type to string with units or dimensions
        - Add assertions to the generated module (if appropriate), and have the option to enable or disable assertions.
    - Unit tests for all procedures.
    - Characterization test comparing against known valid `units.f90`.
    - Test exponentiation functions.
    - Compare compile and run times with and without `units`. Look at compile time for `units.mod` and also something calling the module separately.
        - `make benchmark`
    - Better type names:
        - Type names which lead to good error messages are best. Example error messages:
            - gfortran: `Error: Cannot convert TYPE(unit_p10000_p00000_m10000) to TYPE(unit_p10000_p00000_p00000) at (1)`. This indicates that there's a physical dimension checking error, but isn't clear about what the expected and actual dimensions are.
            - ifx: `error #6197: An assignment of different structure types is invalid.` (So ifx doesn't say what the types are.)
    - How to handle physical dimensions with AD?
        - `diff(f, x)`: Different return types depending on `x` and `y`.
        - But how can I link `x` to the index of the `dv` member variable? I could try something like `diff(f, x, 1)` where `1` is the index.
        - Alternatively, for `diff(f, x)`, since `x` doesn't actually correspond to the *numerical value* of `x`, `x` could be a variable with the same type and a value `x%v` which corresponds to the index to differentiate with respect to.
        - I could make `x` a different type than whatever its physical dimensions would imply. This different type would be a differential version which could contain the index instead of the value.
    - Test with AD.
    - Test with arrays instead of scalars.
    - Recursion to handle arbitrary numbers of exponents.
    - `real(...)` to convert `unitless` to `real(kind=WP)` for when an intrinsic or something else that expects a `real(kind=WP)` isn't available. Also: `int`.
    - Table with times for various compilers on the same computer, as a function of number of units generated:
        - Running genunits
        - Compiling units.f90
        - Compiling test_units.f90 with units
        - Compiling test_real.f90 without units (otherwise identical)
        - Running test_units.f90 with units
        - Running test_real.f90 without units (otherwise identical, to show effect on run-time performance)
    - Compare error messages in different compilers for units.f90
        - If necessary, request that lfortran type error message be similar to gfortran to be as useful as possible for units.f90.
    - units test with operations on 3 or more different units to make sure the output is correct
    - Check for spaces at the end of lines.
    - Lint the generated file units.f90.
    - Namelist group `template` which will read in a template and create versions of the procedure for all units and the proper interface block. Until Fortran has good generics, this is the only way to get a generic procedure
        - `&template file="file.f90" /`
        - Example: `swap_alloc` for all units. This takes two arguments and has a non-trivial procedure body, so it can't be handled like intrinsics.
    - Have a section listing what various error messages shown by various compilers mean. Some of these error messages are not particularly clear and that harms debugging. Also note which compilers have more useful error messages for genunits.
    - absolute vs. offset vs. relative units
- `make install` to install genunits.
- Option to disable automatic differentiation in Makefile for speed.

Later:

- add names to deeply nested `if`s and `do`s in unittest
- Search for `TODO` and finish those tasks.
- fmutate.f90:
    - Start with deleting lines and one other mutation operator. The reason to have two is to have the infrastructure for multiple mutation operators from the start.
    - Get papers for FORTRAN 77 mutation tester to see what that did.
        - acree_mutation_1979
        - budd_mutation_1979
        - king_fortran_1991
            - <https://web.archive.org/web/20221016055309/http://cs.gmu.edu/~offutt/rsrch/mut.html#MOTHRA>
    - Avoid dependency on external regex library. Build in the minimum regex that you need.
    - Make mutation rules in a human-readable file. This will allow you to easily add new rules. A namelist file would work.
    - Check /home/ben/notes/programming/correctness/code-testing.txt for more ideas.
    - Note: This will be brittle in the sense that it will only work for my own particular coding style.
    - Distinguish between compilation errors and test failures in the mutation score.
    - Mutation tester should not touch assertions.
        - But it should note which assertions never fail as below.
    - Make highly parallelizable.
        - Apply the mutation operators in batches in parallel. This will require a pure random number generator.
        - Run the compiler in the next stage in parallel. This will allow me to note if the compilation fails as well.
        - In the next stage, queue the codes that compiled and run them in parallel.
    - List tests that always pass. Check these tests to make sure that they actually discriminate between working and non-working code.
        - List percent of times a test fails with a mutation. Sort the list to see which tests are most and least sensitive/discriminating.
        - For tests that always pass, reduce tolerances so that the tests are more sensitive.
        - For faster testing, consider eliminating tests which always pass, particularly if they take a long time.
    - Mutation operators:
        - `comment_line`: Comment out non-empty lines.
        - `switch_arithmetic_operator`: Switch arithmetic operators (`+`, `-`, `*`, `/`).
        - `switch_comparison_operator`: Switch comparison operators (`>`, `<`, `==`, `>=`, `<=`, `/=`).
        - `off_by_one_assignment`: Add or subtract one in an assignment (or start of a loop).
        - `off_by_one_do_loop_end`: Add or subtract one at the end of a loop
        - `off_by_one_indices_or_arguments`: Add or subtract one in indices or procedure arguments.
        - TODO: mutation operators like the off-by-one operators that change the sign.
        - `switch_variables`: Switch variables.
        - `return`: Prematurely `return` in a procedure.
        - `cycle`: Prematurely `cycle` in a loop.
        - `exit`: Prematurely `exit` in a loop.
        - `zero`: Set a variable to zero in an assignment (or at the start of a loop).
        - `function_result`: Mutate `function` result values.
        - `subroutine_out`: Mutate subroutine `intent(out)` and `intent(in out)` values.
        - `array_size`: Increase or decrease array sizes by one.
        - `delete_term`: Delete random equation terms. (Thought after skimming [this paper](https://doi.org/10.1115/1.4049322): Code coverage misses equation terms. A mutation tester which deletes random equation terms could be useful.)
        - Swap intrinsics like sin and cos which are likely to be accidentally switched.
        - Mutate `intent(in)` to `intent(out)`.
        - Mutate `intent(out)` to `intent(in)`.
        - Change order of exponentiation: `x**y` to `y**x`.
        - changing order of magnitude of numbers
        - moving parentheses (common mistake)
    - When complete, add here: <https://fortranwiki.org/fortran/show/Mutation+testing+frameworks>
- `purerng`:
    - `set_determ`: Convenience function to convert `real` array to `RNG_DETERM` seed
    - For arrays: One `rng_type` per `harvest`. `random_seed` uses spacing in lecuyer_efficient_1988 to set for arrays.
        - lecuyer_implementing_1991
    - Create `stats` module with `mean` and `std` to do some basic tests on the `RNG_LECUYER` random number generator.
        - <https://stdlib.fortran-lang.org/page/specs/stdlib_stats.html>
        - <https://en.wikipedia.org/wiki/Variance#Unbiased_sample_variance>
        - <https://en.wikipedia.org/wiki/Continuous_uniform_distribution>
    - Move `rand_int`, `rand_uniform`, and `rand_cauchy` from ga.f90 to `purerng`. Change their names to be more similar to SciPy or NumPy.
    - better `random_seed()`
    - Switch `random_seed` to use a return code rather than `error stop` to make it more easily tested?
- compiler_tests.f90: Tests for intrinsics used in these libraries.
    - How can I identify all the intrinsics used here?
    - accuracy of important intrinsics
- ga.f90: Module for derivative-free optimization of `real`s with a genetic algorithm.
    - Make ga.f90 use rngmod.f90.
    - herrera_tackling_1998
    - Have multiple outputs.
        - `chromo%f`
        - `chromo%f_set`
        - `chromo%out(:)` (for non-objective function outputs that may be of interest)
- debugtype.f90: Module which implements a derived type to replace `real` with the following debugging capabilities:
    - Monte Carlo sensitivity analysis on floating point operations to help identify expressions contributing to floating point inaccuracy. This allows to find operations with inaccuracy worse than a threshold, rather than finding *all* inexact floating-point operations as tools like gfortran's `ffpe-trap=inexact` do. The latter approach leads to too many reported problems. Prioritizing floating-point errors by their magnitude makes sense.
        - parker_monte_1997-1
    - FLOP counting.
    - Something like Monte Carlo arithmetic can be used to identify sections of code that contribute the most to uncertainty, like Monte Carlo arithmetic finds sections of code that are most sensitive to round-off error.
    - metcalf_modern_2018 p. 309: type-bound operators so that you don't have to `use` the operators
    - Use `pure` logging for this?
    - Upper and lower bounds for each variable.
- Have Python script to insert probes into (instrument) Fortran code, particularly for Monte Carlo arithmetic.
    - <https://fortran-lang.discourse.group/t/free-plusfort-licence-for-fortran-discourse-users/2609/5?u=btrettel>
        - > SPAG is able to insert calls to probes at various points in your code (see below).
    - <https://docs.cypress.io/guides/tooling/code-coverage>
    - Don't insert probes into `pure` and `elemental` procedures.
- nmlfuzz.f90: namelist fuzz tester
    - Intentionally pick inputs which pass input validation but cause the program to fail.
    - Make depend on ga.f90
        - Alternatively: Combine fuzzing and automatic differentiation when possible to find bad program states.
    - Use metaprogramming to make work since Fortran can't really do that well at present?
        - Have a computer-generated module that converts from genetic algorithm chromosome to namelist.
    - Make similar to <https://en.wikipedia.org/wiki/American_Fuzzy_Lop_(software)>.
    - Use fuzzing primarily to find assertion violations with integration tests.
    - I guess the objective function includes the code coverage and whether or not an assertion violation occurred.
    - For speed, incentivize causing assertion failures as quickly as possible. The objective function is a function of both whether the code ran successfully or not and how quickly it failed if it did fail.
- f90lint: Simple linter for Fortran to enforce anything that can't be enforced with a regex linter.
    - Enforce some Power of 10 rules, particularly procedure lengths.
    - Measure and enforce code comment density? Assertions count towards this.
        - <https://dirkriehle.com/2009/02/04/the-sweet-spot-of-code-commenting-in-open-source/comment-page-1/>
    - Require construct names for nested `do` loops and `if` statements.
    - Check that assertions have unique messages. List relevant variable values in error message.
- semgrep static analysis
- <https://en.wikipedia.org/wiki/Quasi-Monte_Carlo_method>
- Sensitivity analysis for model parameters.
    - <https://en.wikipedia.org/wiki/Variance-based_sensitivity_analysis>
    - Use AD for sensitivity analysis for important inputs? Make it possible to turn off AD for these inputs during "production" runs for speed.
- input validation
    - Write module to ease input validation. For example, a subroutine to write a message about a variable being out of bounds.
    - `call validate_bounds(x, "x", rc, lower=0, lower_inclusive=.true.)`
        - message: "x must be greater than or equal to 0."
    - `call validate_bounds(x, "x", rc, lower=0)`
        - message: "x must be greater than 0."
        - I don't think that this is not inclusive is obvious enough.
- data validation
    - Base on <https://pandera.readthedocs.io/en/stable/index.html>?
- latex.f90:
    - Calculated numbers in papers: Write procedure to output LaTeX code to a file (appending by default) with a particular number format. Could pass in a Fortran format string.
    - Include in io.f90?
- read and save CSV and Sqlite files:
    - regex validation field for CSV
- convergence.f90: convergence testing framework
    - grid convergence
    - temporal convergence
    - MC convergence
- Add model validation subroutines (AIC, cross-validation, basic idea of checking whether model is within experimental uncertainty as often as it should be, etc.), calibration subroutines (genetic algorithm for modeling fitting, MCMC to handle uncertainties, etc.)
- Poisson solvers, using same or similar interface as FISHPACK
    - <https://people.sc.fsu.edu/~jburkardt/f77_src/fishpack/fishpack.html>
        - Old: <https://people.math.sc.edu/Burkardt/f77_src/fishpack/fishpack.html>
    - <https://github.com/firemodels/fds/blob/master/Source/pois.f90>
    - <https://github.com/jlokimlin/fishpack>
    - <https://www.netlib.org/fishpack/>
    - <https://ascl.net/1609.005>
    - <https://arc.ucar.edu/knowledge_base/71991310>
        - <https://github.com/NCAR/NCAR-Classic-Libraries-for-Geophysics>
- `io.f90`:
    - convenience subroutines
        - `print_box` (other similar things for the most important messages that I don't want to miss)
            - <https://fortran-lang.discourse.group/t/fortran-code-snippets/2150/24>
        - `print_table*` for iterative progress in particular.
            - `print_table_heading`
            - `print_table_row` (different versions for integer first columns and character first columns?)
            - Also useful for input to compare defaults and current values. See oran_numerical_1987 p. 75.
            - Column heading could go off-screen for long tables, so reprint the heading periodically?
        - `print_dict`
            - Inspired by <https://youtu.be/PxmvTsrCTZg?t=103>:
                - `iteration=2200 residual=0.0937`
            - This is good for long lists because the column header in the table can go off-screen.
        - Look into how other CFD softwares output iterative progress for ideas. Which metrics do they output?
- Add tests to compare speed of parallel vs. serial
- unittest.f90
    - maybe: Instead of `integer_eq`, `real_eq`, use generic `eq`?
    - Ensure that all test messages are unique.
    - Keep track of test results so that you know whether a test has ever failed, and thus whether it is discriminating. (bowes_how_2017 p. 3L)
- Break `prec.f90` into `types_dp.f90` and `types_sp.f90`. Both of these modules will be named `types` and are interchangeable. These modules only define `WP`. Constants like `PI` should then go in a separate `constants.f90` file which depends on the `types` module choice.
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/types.f90>
    - <https://github.com/certik/fortran-utils/blob/b43bd24cd421509a5bc6d3b9c3eeae8ce856ed88/src/constants.f90>
- A module containing errno codes, other internal return codes, and exit codes. Could make a derived type with the number and a message.
- Detect if certain compilers are present and don't run those in `make all` if they are not present. This will allow your Makefile to work on all your different computers.
- Make an assertion which takes an array to help avoid the problem of only the first failing assertion
    - `check` helps with this too, but an `assert_all` would be convenient if I simply want to check a bunch of things at once.
    - <https://blog.ploeh.dk/2022/11/07/applicative-assertions/>
    - Can make `assert_all` use `do_concurrent` to have a faster assertion.
- timer.f90
    - Data type contains both CPU time and wall clock time for comparison?
    - Tests
        - serial case where CPU and wall time should be close.
        - parallel case where CPU time should be a multiple of wall time
        - separate non-standard test code using `sleep(1)`
            - <https://gcc.gnu.org/onlinedocs/gcc-7.5.0/gfortran/SLEEP.html>
            - <https://www.intel.com/content/www/us/en/docs/fortran-compiler/developer-guide-reference/2024-0/sleep.html>
- `purerng`
    - Add more rigorous tests for random number generators. (Low priority as I just implemented a common random number generator, which should be good enough to get started.)
- regex.f90 (Could be useful for fmutate.f90.)
    - <https://fortran-lang.discourse.group/t/the-maturity-of-the-fortran-open-source-ecosystem/7563/2>
    - <https://github.com/perazz/fortran-regex>
    - Fork, add asserts and tests? Or just use as-is to get started faster?
- autodiff.f90
    - Modify your AD to use SIMD vectorization. Use `do concurrent` with OpenMP or OpenACC directives? See personal notes on automatic differentiation for other speed ideas too.
    - Can declare certain derivatives as "active" or "inactive to easily enable or disable (respectively) differentiation with respect to particular variables at compile or run time for speed. Not yet sure how to pick `dv` indices in this case. With allocatable `dv`, this can be done at run time.
    - Add comparison operators
- To-do routine in code to cause compilation to fail.
- `nmllog`
    - When nvfortran supports writing namelists to internal variables, support adding a custom namelist to the output. Then you can have custom variables in `nmllog` output.
- Add linters.
    - Add directory for flinter in tests to make sure that Flinter actually flags bad code. Have one test for good code too which should not be flagged.
    - Camfort
    - <http://simconglobal.com/fpt_summary.html>
    - <https://fortran.uk/fortran-analysis-and-refactoring-with-plusfort/plusfort-evaluation-version/>
    - <https://www.forcheck.nl/index.html>
- genunits:
    - For reading data from CSV files, a compile-time check can't be done. But you can make a derived type which contains the exponents, and corresponding subroutines to check that the output type matches the input type. There will have to be a lot of auto-generated subroutines, but it'll work.
    - FPM installation
    - New GitHub repository specifically for this.
    - Advertising:
        - Post on Fortran Discourse.
        - Create Fortran Wiki page on "Physical units" and list it there.
- Bayesian inference Fortran module, to solve basic problems like the probabity of actually having breast cancer in Yudkowsky's "intyutive explanation" or whodunits. Use log probability or whatever is appropriate internally.
- How to do pure Monte Carlo uncertainty propagation? Include the RNG type in the MC derived type?
- Along side fmutate, make a simple test case reduction program for Fortran (freduce?). Just delete lines to reduce test cases.
    - <https://gcc.gnu.org/pipermail/fortran/2009-October/030302.html>
- dataplot-like approach to ease adding tests (but use namelists instead of a single CSV file)
- Use exiftool in combination with gnuplot to add metadata to plots to (for example) ease identification of which data was used to produce the plot. Add comments to DXF files to do the same.
- Verify checksums of all generated images that have them (PNG, for example).
- Build system improvements:
    - Fortran module dependencies being wrong
        - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/18>
            - > I will note that from a quick scan of your script and makefile, it doesn’t actually appear to guarantee correct order of compilation (i.e. your .o files don’t depend on .mod files).
        - <https://fortran-lang.discourse.group/t/why-should-i-use-cmake/953/23>
            - > For Fortran, an object file depends on the source file it is compiled from AND all the .mod files for any modules USEd in the source file. A .mod file depends on the source file in which that module is defined. An executable depends on all the object files for all the code it uses, and code they use, etc, even if that code wasn’t in a module, and so doesn’t get included via a USE statement.
    - Making compatible with FPM.
- Tests
    - Test `exit_code_eq` better. Check if the file is kept or not.
    - Make sure that debug builds enable assertions by looking at the test log output.
- Build system improvements:
    - Making work with NMAKE, GNU Make, and BSD Make.
        - Figure out how to pass the `-f` argument to the `MAKE` macro so that recursive make works (for example, `bmake -f BSDmakefile all` and `pdpmake -f PDPmakefile all`).
        - Figure out how to specify `BUILD` and `FC` in pdpmake.
        - Figure out how to add back `test ! -e fort.*` and `test ! -e FORT.*` to tests as I don't know what the Windows equivalent is.
            - Do these checks in Fortran?
- interval arithmetic
    - Combination with automatic differentiation: <http://www.mscs.mu.edu/%7Egeorgec/IFAQ/rocco1.html>
- `constrained` data type
    - <http://www.acorvid.com/2017/12/13/what-i-miss-when-writing-fortran/>
        - > Constrained reals; for example, absolute mass, pressure, or temperature variables which throw an exception if they become negative. This is a first-class feature of types in Ada (constrained subtype)
    - Can be done with a derived type with custom operators.
- Build system improvements:
    - Replace PDPmakefile with POSIXmakefile that is strictly POSIX (has no `include` or any other non-POSIX things) and should work on IBM AIX make too. This file can be constructed from the other files via `make POSIXmakefile`. Don't set `FC` and whatnot, instead set those via the command line or defaults?
    - Intel and Cray compilers: make variable to switch between address and thread sanitizers, compile with both when doing `make all` (`SFLAGS`?)
    - `PFLAGS` make macro to switch between GPU and CPU for ifx, nvfortran, etc.
- f90lint:
    - Add tests for remaining modules which aren't passing.
    - Check for modules which don't have tests.
    - Measure `TODO` density and have bound on it to keep them current.
    - Identify untested procedures by looking at `use` lines in tests. This won't work for type-bound procedures, though.
    - Require that all functions be `pure`.
    - Output checking:
        - Presence of files that should not be there: `fort.*`, `FORT.*`
        - Fortran format overflow: `*` in ifort/gfortran/crayftn/nvfortran
        - `forrtl: error`
        - `NaN`
        - `Infinity`
- purerng.f90 low priority:
    - Make xoshiro256** only work with `REAL64` and `INT64` with radix 2 as it seems designed around those based on the bit manipulation.
    - Change `I10` to `INT64` to work with xoshiro256**.
    - Test that `INT64` has enough precision for the `lecuyer` RNG.
- nmlcli.f90
    - Could modify `get_namelist` approach to make CLI use more typical `--` flags. `--flag` could also be converted to `flag=.true.` for `logical`s.
    - `--version`: integrates with revision.f90
    - How can I get descriptions of each option in `--help`? Manually? Parsing comments in the namelist file that is included?
    - <https://fortran-lang.discourse.group/t/are-namelists-portable/1212/10>
    - <https://github.com/urbanjost/M_CLI?tab=readme-ov-file>
    - <https://fortranwiki.org/fortran/show/get_namelist>
- Multidimensional Newton solver
    - <https://web.mit.edu/18.06/www/Spring17/Multidimensional-Newton.pdf>
        - <https://gcc.gnu.org/onlinedocs/gfortran/NORM2.html>
    - <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html>
    - <https://people.sc.fsu.edu/~jburkardt/f_src/newton_rc/newton_rc.html>
